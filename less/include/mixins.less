@import (once) "variables";

.clear() {
    &:before,
    &:after {
        display: table;
        content: "";
    }
    &:after {
        clear: both;
    }
}

.user-select(@mode: none) {
    user-select: @mode;
}

.box-sizing(@model: border-box) {
    box-sizing: @model;
}

.px2rem(@attr: width; @size: 16; @unit: rem) {
    .get-values(length(@size));
    .get-values(@s, @i: 1) when (@i =< length(@size)) {
        @current_value: extract(@size, @i);

        & when not(@current_value = 0) {
                @{attr}+_: unit( @current_value / 16, @unit );
        }

        & when (@current_value = 0) {
                @{attr}+_: 0;
        }

        .get-values(@s, @i + 1);
    }
}

.rem2px(@attr: width; @size: 16; @unit: px) {
    .get-values(length(@size));
    .get-values(@s, @i: 1) when (@i =< length(@size)) {
        @current_value: extract(@size, @i);

        & when not(@current_value = 0) {
                @{attr}+_: unit( 16 * @current_value, @unit );
        }

        & when (@current_value = 0) {
                @{attr}+_: 0;
        }

        .get-values(@s, @i + 1);
    }
}

.pt2px(@attr: width; @size: 16; @unit: px) {
    .get-values(length(@size));
    .get-values(@s, @i: 1) when (@i =< length(@size)) {
        @current_value: extract(@size, @i);

        & when not(@current_value = 0) {
                @{attr}+_: unit( round(@current_value * 1.333333) , @unit );
        }

        & when (@current_value = 0) {
                @{attr}+_: 0;
        }

        .get-values(@s, @i + 1);
    }
}

.px2pt(@attr: width; @size: 16; @unit: pt) {
    .get-values(length(@size));
    .get-values(@s, @i: 1) when (@i =< length(@size)) {
        @current_value: extract(@size, @i);

        & when not(@current_value = 0) {
                @{attr}+_: unit( round(.75 * @current_value), @unit );
        }

        & when (@current_value = 0) {
                @{attr}+_: 0;
        }

        .get-values(@s, @i + 1);
    }
}

.pt2rem(@attr: width; @size: 16; @unit: rem){
    .get-values(length(@size));
    .get-values(@s, @i: 1) when (@i =< length(@size)) {
        @current_value: extract(@size, @i);

        & when not(@current_value = 0) {
                @{attr}+_: unit( round(@current_value * 1.333333 / 16), @unit );
        }

        & when (@current_value = 0) {
                @{attr}+_: 0;
        }

        .get-values(@s, @i + 1);
    }
}

.rem2pt(@attr: width; @size: 16; @unit: pt){
    .get-values(length(@size));
    .get-values(@s, @i: 1) when (@i =< length(@size)) {
        @current_value: extract(@size, @i);

        & when not(@current_value = 0) {
                @{attr}+_: unit( round(.75 * 16 * @current_value), @unit );
        }

        & when (@current_value = 0) {
                @{attr}+_: 0;
        }

        .get-values(@s, @i + 1);
    }
}

.align(@mode) {
    text-align: @mode;
}

.flash-list() {
    margin: 0;
    padding: 0;
    list-style: none inside;
}

.perspective(@perspective) {
    transform: perspective(@perspective);
}
.rotate(@degrees) {
    transform: rotate(@degrees);
}
.rotateX(@degrees) {
    transform: rotateX(@degrees);
}
.rotateY(@degrees) {
    transform: rotateY(@degrees);
}
.rotateZ(@degrees) {
    transform: rotateZ(@degrees);
}
.scale(@ratio) {
    transform: scale(@ratio);
}
.scaleX(@ratio) {
    transform: scaleX(@ratio);
}
.scaleY(@ratio) {
    transform: scaleY(@ratio);
}
.translate(@x: 0, @y: 0) {
    transform: translate(@x, @y);
}
.translateX(@x: 0) {
    transform: translateX(@x);
}
.translateY(@y: 0) {
    transform: translateY(@y);
}
.skew(@x: 0, @y: 0) {
    transform: skew(@x, @y);
}
.translate3d(@x: 0, @y: 0, @z: 0) {
    transform: translate(@x, @y, @z);
}

.transformOrigin(@origin) {
    transform-origin: @origin;
}

.transition(@target: all, @time: 1s, @func: ease){
    transition: @target @time @func;
}

.animate(@params){
    animation: @params;
}

.box(@size: 16px) {
    width: @size;
    height: @size;
}

.square(@size: 16px) {
    width: @size;
    height: @size;
}

.rect(@width, @height) {
    width: @width;
    height: @height;
}

.circle(@size){
    .box(@size);
    border-radius: 50%;
}

.fix-to-top() {
    position: fixed;
    right: 0;
    left: 0;
    bottom: auto;
    top: 0;
}

.fix-to-bottom() {
    position: fixed;
    right: 0;
    left: 0;
    bottom: 0;
    top: auto;
}

.shadow(@size) when (@size = 0) {
    box-shadow: none;
    border: 1px solid #eee;
}

.shadow(@size) when (@size = 1) {
    box-shadow: 0 2px 10px 0 rgba(0, 0, 0, 0.16), 0 2px 5px 0 rgba(0, 0, 0, 0.26);
}

.shadow(@size) when (@size = 2) {
    box-shadow: 0 6px 20px 0 rgba(0, 0, 0, 0.19), 0 8px 17px 0 rgba(0, 0, 0, 0.2);
}

.shadow(@size) when (@size = 3) {
    box-shadow: 0 17px 50px 0 rgba(0, 0, 0, 0.19), 0 12px 15px 0 rgba(0, 0, 0, 0.24);
}

.shadow(@size) when (@size = 4) {
    box-shadow: 0 25px 55px 0 rgba(0, 0, 0, 0.21), 0 16px 28px 0 rgba(0, 0, 0, 0.22);
}

.shadow(@size) when (@size = 5) {
    box-shadow: 0 40px 77px 0 rgba(0, 0, 0, 0.22), 0 27px 24px 0 rgba(0, 0, 0, 0.2);
}

.shadow-right() {
    box-shadow: 10px 0 5px -2px rgba(8,8,8,.22);
}

/**
* Less Long Shadow v2.1.0
* Long shadow generator mixins for inline, block and SVG elements.
*
* Source: https://github.com/zensimilia/less-long-shadow
* Author: Di M Dub
* License: MIT
*
* #long-shadow.inline(@color, @angle, @size);
* #long-shadow.block(@color, @angle, @size, @prefix);
*/

#long-shadow {
    .inline(@color: @gray800, @angle: 45, @size: 10, @flag: 1, @temp: "") when (@size > 0) {
        @angle360: @angle * (pi() / 180);
        @x: round(@flag * cos(@angle360));
        @y: round(@flag * sin(@angle360));
        @shadow: ~"@{x}px @{y}px 0px @{color}";
        @close: ~"@{shadow}, @{temp}";
        @alltogether: ~"@{close} 0px 0px 0px @{color}";

        .loop(@string, @index) when (@index < 1) {
            text-shadow: @string;
        }

        .loop(@alltogether, @size - 1);
        .inline(@color, @angle, @size - 1,@flag + 1, @close);
    }

    .block(@color: @gray800, @angle: 45, @size: 10, @prefix: 1, @flag: 1, @temp: "") when (@size > 0) {
        @angle360: @angle * (pi() / 180);
        @x: round(@flag * cos(@angle360));
        @y: round(@flag * sin(@angle360));
        @shadow: ~"@{x}px @{y}px 0px @{color}";
        @close: ~"@{shadow}, @{temp}";
        @alltogether: ~"@{close} 0px 0px 0px @{color}";

        .loop(@string, @index) when (@index < 1) {
            box-shadow: @string;
        }

        .loopPrefix(@string, @index) when (@index < 1) and (@prefix > 0) {
            -webkit-box-shadow: @string;
            -moz-box-shadow: @string;
        }

        .loop(@alltogether, @size - 1);
        .loopPrefix(@alltogether, @size - 1);
        .block(@color, @angle, @size - 1, @prefix, @flag + 1, @close);
    }

    .svg(@color: @gray800, @angle: 45, @size: 10, @prefix: 1, @flag: 1, @temp: "") when (@size > 0) {
        @angle360: @angle * (pi() / 180);
        @x: round(@flag * cos(@angle360));
        @y: round(@flag * sin(@angle360));
        @shadow: ~"@{x}px @{y}px 0px @{color}";
        @close: ~"@{shadow}) drop-shadow(@{temp}";
        @alltogether: ~"drop-shadow(@{close} 0px 0px 0px @{color})";

        .loop(@string, @index) when (@index < 1) {
            filter: @string;
        }

        .loopPrefix(@string, @index) when (@index < 1) and (@prefix > 0) {
            -webkit-filter: @string;
        }

        .loop(@alltogether, @size - 1);
        .loopPrefix(@alltogether, @size - 1);
        .svg(@color, @angle, @size - 1, @prefix, @flag + 1, @close);
    }
}

.generate-indent(@size, @i: 1) when (@i =< @indentIndexLength) {
    @size: extract(@indentIndexes, @i);
    @indentID: @size / 8;

    * .padding@{indentID} {padding: unit(@size, px);}
    * .margin@{indentID} {margin: unit(@size, px);}

    .generate-indent(@size, @i + 1);
}

.set-border(@size: 1px, @color: @gray200, @type: solid) {
    border: @size @color @type;
}

.enableGPU() {
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
}